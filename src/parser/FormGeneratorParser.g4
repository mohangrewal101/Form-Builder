parser grammar FormGeneratorParser;
options { tokenVocab=FormGeneratorLexer; }

program: OBJECT_START pages (SEP functions)? (SEP variables)?  OBJECT_END EOF;

// Pages Array
pages: PAGES_KEY COLON page_array;
page_array: LIST_START page (SEP page)* LIST_END;
page: OBJECT_START page_fields OBJECT_END (SEP OBJECT_START page_fields OBJECT_END)*;
page_fields: page_field (SEP page_field)*;
page_field: (id_field | header_field | instructions_field | goTo_field | questions_field | displayQuestions_field);
id_field: ID_KEY COLON (STRING | expression);
header_field: HEADER_KEY COLON (STRING | function_call | expression | VARIABLE_NAME);
instructions_field: INSTRUCTIONS_KEY COLON (STRING | function_call | expression | VARIABLE_NAME);
questions_field: QUESTIONS_KEY COLON question_array;
goTo_field: GOTO_KEY COLON (STRING | function_call | expression);
displayQuestions_field: DISPLAY_QUESTIONS_KEY COLON (DISPLAY_ALL | NUM);

// Vars object
variables: VARIABLES_KEY COLON variables_object;
variables_object: OBJECT_START (VARIABLE_NAME COLON variable_value (SEP VARIABLE_NAME COLON variable_value)*)? OBJECT_END;
variable_value: array | NUM | STRING | REGEX | form_state_access | static_function | expression | function_call | form_state_access;

// Question Array
question_array: LIST_START (question (SEP question)*)? LIST_END;
question: OBJECT_START question_fields OBJECT_END (SEP OBJECT_START question_fields OBJECT_END)*;
question_fields: question_field (SEP question_field)*;
question_field: id_field | type_field | label_field | options_field | dependsOn_field | displayIf_field | loop_field | isRequired_field | correctAnswer_field | variables;
type_field: TYPE_KEY COLON question_type;
label_field: LABEL_KEY COLON (STRING | function_call | expression | VARIABLE_NAME);
options_field: OPTIONS_KEY COLON (VARIABLE_NAME | function_call | array);
dependsOn_field: DEPENDS_ON_KEY COLON STRING;
displayIf_field: DISPLAY_IF_KEY COLON (STRING | REGEX | function_call | expression);
loop_field: LOOP_KEY COLON NUM;
isRequired_field: IS_REQUIRED_KEY COLON boolean;
correctAnswer_field: CORRECT_ANSWER_KEY COLON (STRING | NUM | REGEX | function_call | expression | VARIABLE_NAME);


// Array & object definition
/** Start Code Generated by Copilot on Jan 30, 2024 */
array: LIST_START (array_value (SEP array_value)*)? LIST_END;
array_value: NUM | STRING | VARIABLE_NAME;

object: OBJECT_START (object_value (SEP object_value)*)? OBJECT_END;
object_value: VARIABLE_NAME COLON (NUM | STRING);
/** End Code Generated by Copilot on Jan 30, 2024 */


// Question Types
question_type: TEXT_INPUT | RADIO | CHECKBOX | DROPDOWN;

// Functions
functions: FUNCTIONS_KEY COLON function_array;
function_array: LIST_START (function (SEP function)*)? LIST_END;
function: VARIABLE_NAME function_params function_body;
function_params: PAREN_START (parameter (SEP parameter)*)? PAREN_END;
parameter: expression | STRING | NUM | VARIABLE_NAME | static_function | function_call | form_state_access;
function_body: OBJECT_START (statement)* RETURN (VARIABLE_NAME | STRING | NUM | expression | static_function | function_call | form_state_access | array) OBJECT_END;
statement: (expression | conditional | static_function)+;
function_call: VARIABLE_NAME function_params;

// Conditional Statements
conditional: IF_KEY condition cond_body (ELSE_KEY IF_KEY condition function_body)* (ELSE_KEY cond_body)?;
condition: PAREN_START expression PAREN_END;
cond_body: OBJECT_START (statement)* (RETURN (VARIABLE_NAME | STRING | NUM | expression))? OBJECT_END;


// expressions
expression:  NUM | STRING |unscoped_expression |  scoped_expression;
scoped_expression: (PAREN_START (scoped_expression | unscoped_expression) ((math_op | num_equality_op) (expression | NUM | STRING))* PAREN_END);
unscoped_expression:  math_expression  |  string_expression  |  boolean_expression ;
math_expression: ((NUM | VARIABLE_NAME) math_op (NUM | VARIABLE_NAME)) | ((NUM | VARIABLE_NAME) math_op expression);
string_expression: ((STRING | VARIABLE_NAME) PLUS (STRING | NUM | VARIABLE_NAME)) | ((STRING | VARIABLE_NAME) PLUS expression);
boolean_expression: ((STRING | VARIABLE_NAME) string_equality_op ((STRING | VARIABLE_NAME) | string_equality_op expression)) |
                                        ((NUM | VARIABLE_NAME) num_equality_op ((NUM | VARIABLE_NAME) | num_equality_op expression));

// Static Objects
static_function: FORM_OBJ_KEY DOT STATIC_FORM_NAME function_params; // Form.getRandomInt(3, 19)
form_state_access: FORM_STATE_KEY path_to_key; // FormState['pg-1-id'][q-1-id']
path_to_key: LIST_START STRING LIST_END LIST_START STRING LIST_END; // ['pg-1-id'][q-1-id']

// Misc
boolean: (TRUE | FALSE);
math_op: PLUS | MINUS | MULTIPLY | DIVIDE | MODULO;
string_equality_op: EQUAL | NOT_EQUAL;
num_equality_op: EQUAL | NOT_EQUAL | GREATER | GREATER_EQUAL | LESS | LESS_EQUAL;
